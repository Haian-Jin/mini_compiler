# <center>任务一设计报告</center>



## 一、前言

1. 该文档阐述了我们实现的语言的详细词法、语法和文法，解释了 .l 文件和 .y 文件代码的含义，目的是组内同学能够更好地开展后续工作。
2. 我们实现的是一个类 C 的语言，从网上广为流传的 C--（C Minus）开始，尽可能地向标准 C 语言靠拢。
3. 该文档可能只是我一个人的想法和设计，如有其他想法，请及时沟通。



## 二、C-- 词法

### 2.1 C-- 关键字概述

C-- 的关键字有：

```
if  else  while  int  void  return
```

结合个人意愿和课上所学，我决定将关键字扩展为：

```
数据类型： int  double  void
循环：    do  while  for
分支：    if  else
跳转控制： continue  break  return
```

**此外，以下单词也被列为关键字，但我不打算实现它们**

```
float  char  switch  case  default  struct  unsigned  const  static
```



### 2.2 C-- 词法分析器部分说明

1. 我们不打算实现科学计数法或非十进制等异样的数字表述形式，只接受十进制输入的数字，只接受最普通的带小数点的十进制小数。

   ```
   intNumber ([1-9][0-9]*)|[0-9]
   doubleNumber {intNumber}\.{intNumber}
   ```

   

2. 我们不打算实现 ‘/*’ 形式的注释，仅支持 // 形式的注释。

   ```
   commitLine \/\/.*\n
   ```

   

3. 我们不支持诸如 `'\123'` 这样的 ASCII 码表示字符，只支持直接的 `'a'` 和转义符 `'\n'` 。

   ```
   char \'.\'|\'\\.\'
   ```

   

4. 除了规定的字符以外，所有字符都会导致词法分析不通过。

   ```
   ...
   [\-\^\+\*\/\=\)\(\&\%\!\?\/\'\"\:\;\|\]\[\}\{\~\,\.] {
       echo();
       return yytext[0];
   }
   . {
       errecho();
       return 0;
   }
   ```

   

5. 标识符（变量名字/函数名字）和 C 语言的规范一致。

 

## 三、C-- 文法和部分语义建议



### 3.1 总览

大体来见，一个 C-- 源文件的语句可以分成**定义语句**和**执行语句**两大类。

和C语言一样，所有的**执行语句**必须放在**函数**的里面。所以，**一个 C-- 源文件必须以<font color='red'>定义语句串</font>作为顶层**，也就是说，C-- 源文件由一串全局的定义语句组成。

```yacc
cCode :
        globalDeclaration 
    |   cCode globalDeclaration 
    ;
```

定义语句串是一串定义语句，全局层面的定义语句细分为**变量定义**和**函数定义**，而只有**函数定义**才能够承载**执行语句**。

```
globalDeclaration :
       declaration
    |  functionDeclaration
    ;
```

> ##### 例子：
>
> ![image-20220416142937119](C:\Users\28082\Desktop\编译原理大程\任务一文档.pic\image-20220416142937119.png)



比较特殊的是，我们的语言不支持在执行语句的中间夹杂定义语句。也就是说，在一个语句块内，所有定义语句必须全部写在所有执行语句的前面。

```
statementBlock :
        '{' '}'
    |   '{' statements '}'
    |   '{' localDeclarations '}'
    |   '{' localDeclarations statements '}'
    ;
```

> 注意，globalDeclaration 必然不可能和执行语句夹杂在一起。这是因为，执行语句必须在函数里面。



### 3.2 定义语句

文法上，我将定义语句分成了两大类：全局定义语句 globalDeclaration 和局部定义语句串 localDeclarations。它们之间的区别是，全局定义语句可以生成函数定义，而局部定义语句不能生成函数定义。这是因为，C 语言不支持内嵌地定义函数。

```
globalDeclaration :
       declaration
    |  functionDeclaration
    ;

localDeclarations :
        declaration
    |   localDeclarations declaration
    ;
```

接下来，我将分别阐述变量定义语句 declaration 和函数定义语句 functionDeclaration。

#### 3.2.1 变量定义语句 declaration

一个变量定义语句 declaration 必须以分号结尾。在函数的里面，多个 declaration 连在一起，就变成了 localDeclarations。

一个变量定义语句分为三部分：类型，一串变量名，一个分号。或者，你可以用它来定义一个结构体。

```
declaration :
        type initializations ';'
    |   STRUCT IDENTIFIER '{' structMemberDeclarations '}'
    ;
```

##### 3.2.1.1 类型 type

类型除了可以是单纯地 `int` 、`double` 这样的东西以外，还可以加 `const` 修饰符和 `static` 修饰符；除了是基础数据类型，还可以是结构体的名字 structTypeName。

```
type :
        typeName         
    |   CONST typeName    
    |   STATIC typeName  
    ;

typeName :
        INT            
    |   UNSIGNED INT
    |   CHAR
    |   FLOAT
    |   DOUBLE
    |   VOID 
    |   structTypeName
    ;
```

structTypeName 可以带上它的结构，也可以只是一个结构体名字。

```
structTypeName : 
        STRUCT IDENTIFIER '{' structMemberDeclarations '}'
    |   STRUCT '{' structMemberDeclarations '}'
    |   STRUCT IDENTIFIER
    ;
```

结构体内部的变量定义文法 structMemberDeclarations 和普通的变量定义文法 localDeclarations 几乎一模一样，唯一不同的就是，结构体内部的变量定义文法 structMemberDeclarations 不允许赋初始值。

```
structMemberDeclarations :
        structMemberDeclaration
    |   structMemberDeclarations structMemberDeclaration
    ;

structMemberDeclaration :
        type structMembers ';'
    ;

structMembers :
        variable
    |   structMembers ',' variable
    ;
```

structMembers 和 initializations 的区别就是，structMembers 不能跟等号。

##### 3.2.1.2 定义和初始化串 initializations

定义和初始化串 initializations 是由一系列的定义和初始化 initialization 连在一起形成的。

```
initializations :
        initialization
    |   initializations ',' initialization
    ;
```

initialization 可以只负责定义一个变量，也可以同时给这个变量赋予初始值。

```
initialization :
        variable
    |   variable '=' initialValue
    ;
```

###### 定义 variable

变量 variable 实际上细分成左中右三部分：左边是指针标识 pointerSpecifier，中间是真正的变量标识符 IDENTIFIER，右边是一串变量身份（比如表示数组的`[...]`、表示函数的 `(...)` ）。当然，左边和右边都是可选项，但中间的 IDENTIFIER 必须要有。

```
variable :
        pointerSpecifier variableName   /* int *a; */
    |   variableName
    ;
    
variableName :
        IDENTIFIER  
    |   variableName '[' NUMBER ']'
    |   '(' variable ')' 
    |   IDENTIFIER '(' ')'  
    |   IDENTIFIER '(' paramTypes ')'   
    ;
```

指针标识 pointerSpecifier 指明了指针的类型。这个指针可以是一个普通指针，也可以是指向指针的指针；它可以指向一个普通变量，也可以指向一个 const 变量。

```
pointerSpecifier :
        '*'
    |   pointerSpecifier '*'
    |   '*' CONST
    |   pointerSpecifier '*' CONST
    ;
```

变量名字 variableName 可以直接是一个普通的 IDENTIFIER，也可以左递归地在右边添一串括号来表示自己是数组，或者在右边添**一个**小括号来表示自己是函数。

```
variableName :
        IDENTIFIER  
    |   variableName '[' NUMBER ']'
    |   '(' variable ')' 
    |   IDENTIFIER '(' ')'  
    |   IDENTIFIER '(' paramTypes ')'   
    ;
```

> 语义分析建议：
>
> 1. 忽略掉那个奇怪的 `'(' variable ')'  `，这条产生式用于定义函数指针和数组指针，实在是太过于复杂，我觉得我们难以驾驭。
> 2. 如果选择了产生式 `IDENTIFIER '(' ')'`或者 `IDENTIFIER '(' paramTypes ')'`，那么它是一个函数的**声明**而非**实现**。

如果选择这一条产生式 `variableName : IDENTIFIER '(' paramTypes ')'`，那么参数类型串 paramTypes 负责描述这个函数所接受的各个参数的类型。可以只描述类型而不提供变量名。

```
paramTypeName :
        type  
    |   type variableWithNoName 
    |   type variable   
    ;

variableWithNoName :    
        pointerSpecifier     
    |   variableWithNoNameCore
    ;

variableWithNoNameCore : 
        variableWithNoNameCore '[' NUMBER ']'
    |   '(' variableWithNoName ')' 
    |   variableWithNoNameCore '(' ')' 
    |   variableWithNoNameCore '(' paramTypes ')' 
    |   '[' ']'          
    |   '(' ')'
    |   '(' paramTypes ')' 
    ;
```

> 语义分析建议：不允许只描述类型而不提供变量名，能够极大地减少这部分的工作量。

###### 初始值 initialValue

可以通过一个算式来完成赋值，或者可以用一个大括号来完成对数组的初始化。

```
initialValue :
        '{' initialValues '}'      
    |   assignmentExpression     
    ;
```

其中，assignmentExpression 隶属于 expression，是执行语句的一种，这个之后再说；初始值串 initialValues 是由多个逗号分隔的初始值拼凑而来，结尾没有逗号。

```
initialValues :
        initialValue                 
    |   initialValues ',' initialValue /* int a[10]={1,2,3} */
    ;
```

> 换句话说，我们的语法支持多维数组的初始化，比如 `int mv[4][2]={{1,0},{0,1},{-1,0},{0,-1}};`
>
> 语义分析建议：这块的分析树要设计成递归的模样，这样才能承载多维数组初始化。

#### 3.2.2 函数定义语句 functionDeclaration

虽名叫“定义语句”，但实际上 functionDeclaration 是一个函数实现的语句，而不是单纯的声明。

```
functionDeclaration : 
        type variable statementBlock
    ;
```

类型 type 和变量 variable 已经在上面阐述过。

> 语义分析建议：
>
> 1. variable 下的 variableName 必须走这两条产生式其中的一条：`variableName : IDENTIFIER '(' ')'`、`variableName : IDENTIFIER '(' paramTypes ')'`
> 2. 如果 variableName 走了第二条产生式，那么接下来的 paramTypes 下的 paramType 必须走这一条产生式：`paramTypeName : type variable`

语句块 statementBlock 是用大括号括起来的一个语句串。**在这个语句串里可以进行局部变量定义，但所有定义语句 localDeclarations 必须放在所有执行语句 statements 之前**

```
statementBlock :
        '{' '}' 
    |   '{' statements '}'
    |   '{' localDeclarations '}'
    |   '{' localDeclarations statements '}'
    ;
```

关于 statement、statements 和 statementBlock 等的陈述，请看 3.3。

局部变量定义语句串 localDeclarations 是由许多变量定义语句 declaration 组成的。它不能生成函数定义语句，只能生成变量定义语句。

```
localDeclarations :
        declaration
    |   localDeclarations declaration
    ;
```

### 3.3 执行语句

执行语句串 statements 是一系列执行语句 statement 连在一起得到的。

```
statements :  
        statement
    |   statements statement
    ;
```

执行语句 statement 可分为五类：计算语句 expressionStatement，循环语句 loopStatement，分支语句 branchStatement，跳转语句 jumpStatement，语句块 statementBlock。

```
statement : 
        expressionStatement 
    |   loopStatement
    |   statementBlock   
    |   branchStatement   
    |   jumpStatement
    ;
```

其中，计算语句 expressionStatement 和跳转语句 jumpStatement 必须以封号结尾，而语句块 statementBlock 后面不必跟一个封号。

在循环语句 loopStatement 和分支语句 branchStatement 中，如果后面跟的是语句块，那结尾就不要封号；如果后面跟的是单个语句，那么结尾就要封号。

> 这就是大家最熟悉的 C 语言的语法而已，只不过现在写出了变得很啰嗦。

#### 3.3.1 计算语句

计算语句 expressionStatement 是由一个表达式加上一个封号组成的。或者干脆是一条空语句。

```
expressionStatement :
        ';'
    |   expression ';'
    ;
```

> 文法分析提示：空语句是表达式语句。
>
> 在 C 语言中，你可以使用封号来完成缩进，以代替 tab 的功能。但我们的语言不行，因为我们不允许执行语句出现在函数的外面。

表达式 expression 就是经典的 C 语言表达式，算符们大体上拥有 16 个优先级，细分的话其实有大约 18 个优先级。这里不多做阐述了。

#### 3.3.2 循环语句

有三种循环语句：`for`、`while`、`do-while`。

```
loopStatement :
        FOR '(' expressionStatement expressionStatement expression ')' statement
    |   WHILE '(' expression ')' statement
    |   DO statement WHILE '(' expression ')' ';'
    ;
```

在 for 循环里，我们不支持类似  `for(int i=0;i<10;i++)` 的嵌入式定义变量。

> 提醒一下，以下两个写法在 C 语言中是等价的：
>
> ```
> for(A;B;C){
> 	...
> }
> 
> A;
> while(B){
> 	...
> 	C;
> }
> ```

#### 3.3.3 分支语句

有两种分支语句，`if-else` 和 `switch-case`。

```
branchStatement :
        IF '(' expression ')' statement
    |   IF '(' expression ')' statement ELSE statement 
    |   SWITCH '(' expression ')' caseBlock
    ;  
```

> 语义分析建议：
>
> 1. 由于 else 悬挂问题，不要将第二行移到第一行去，否则 else 匹配的是最远 if 而不是最近 if。
> 2. 可以不实现 switch-case 语句，极大地减少工作量。

#### 3.3.4 跳转语句

这里的跳转语句是显式的跳转语句。尽管分支和循环在翻译成汇编之后全都是跳转语句，但 C 语言里跳转和分支循环是分开的。

有三类跳转语句：负责函数返回的 `return`，负责循环控制的 `continue`、`break`，还有无条件跳转语句 `goto`。

```
jumpStatement :
        RETURN ';'
    |   RETURN expression ';'
    |   CONTINUE ';'
    |   BREAK ';'
    |   GOTO IDENTIFIER ';'
    ;
```

> 语义分析建议：忽略 goto 语句，这个比较难以实现，而且我也没写 labeledLine 相关的产生式

#### 3.3.5 语句块

语句块是由大括号包裹起来的一堆语句，递归地可以简单写成这样。我们支持语句块内的局部变量的定义，但一个语句块内，必须将所有的定义放在所有其它语句的前面。

```
statementBlock :
        '{' '}'
    |   '{' statements '}'
    |   '{' localDeclarations '}'
    |   '{' localDeclarations statements '}'
    ;
```

语句块一定会跟在函数定义的后面。同时，它还经常出现在循环和分支里面。

> 语义分析建议：
>
> 在循环和分支语句中，statement 必须走这一条产生式 `statement : statementBlock`，这样可以稍微减少工作量。
>
> 换句话说，循环和分支语句必须要用大括号括起来的那种，不允许单行的。

