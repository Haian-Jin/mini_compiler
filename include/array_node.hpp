#pragma once
#include "ast_node.hpp"
#include "expr_node.hpp"

class ExpressionNode;
class IdentifierNode;

/* calcArrayIndex():
     calculate the index of the multiple dimension array
     convert it to single dimension index in r value form
 */
llvm::Value *calcArrayIndex(std::vector<int> arraySizes, std::vector<ExpressionNode *> mArrayIndexs);

class ArrayIndexNode : public ExpressionNode {
public:
    ArrayIndexNode(std::string _symbolName, int childrenNumber, ...);

    ArrayIndexNode(std::string _tokenValue, bool negligible = false);

    ArrayIndexNode(std::string opType, ExpressionNode *lhs,
                   std::vector<ExpressionNode *> rhs, bool isArithmetic = false);

    std::string getVariableName();

    std::string getNodeTypeName() const override;

    Json::Value jsonGen() const override;

    Type_and_Address getTypeAddress() override;

    /* addrGen():
        return the address of the element being accessed
        ind always = 0 except for string's comparison
     */
    llvm::Value *addrGen(int ind = 0) override;

    /*codeGen():
        return the value of the element being accessed
        load it from the address generated by addrGen()
     */
    llvm::Value *codeGen() override;

    std::string op;
    IdentifierNode *mArrayName;
    std::vector<ExpressionNode *> mArrayIndexs;
};


class ArrayAssignmentNode : public ExpressionNode {
    // assign values to the element in array
public:
    std::string getNodeTypeName() const override;

    ArrayAssignmentNode(ArrayIndexNode *lhs, ExpressionNode *rhs);


    Json::Value jsonGen() const override;

    /*codeGen():
        store the r value into array by function CreateAlignedStore
     */
    llvm::Value *codeGen() override;

private:
    std::string op;
    ArrayIndexNode *mLeftHandSide;
    ExpressionNode *mRightHandSide;
};
